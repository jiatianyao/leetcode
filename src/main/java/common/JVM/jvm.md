### 判断垃圾对象两种方式
- 引用计数算法
- 可达性分析算法

##### 引用计数算法
> 对每个对象保存一个整形的引用计数器属性
###### 优点：
1. 实现简单，判断效率高，回收没有延迟性
###### 缺点：
1. 单独计算字段，增加存储开销
2. 每次赋值都更新计数器，增加时间开销
3. 无法处理循环引用情况
 
##### 可达性分析算法
> 以根对象集合（GC Roots）为起点，  
>按照从上到下的方式搜索被跟对象集合所连接的对象是否可达。  
>搜索所走的路径成为引用链，没有引用链，则不可达，标记为垃圾对象

###### GC Root包含：
```puml
A -> B
```
>虚拟机栈中引用的对象（线程中被调用的方法中使用的参数和局部变量）  
>本地方法栈中JNI引用的对象
>方法区中类静态属性引用的对象
>方法去中常量引用的对象

### 回收过程
1. 第一次判断：判断对象不可达
2. 第二次判断：finalize()方法，该方法被垃圾回收器去调用，并且只会调用一次。  
可以完成自我救赎，重新建立可达性关联

### 垃圾清除阶段
当成功区分出存活对象和垃圾对象，GC接下来任务是执行垃圾回收。常见的垃圾收集算法：
1. 标记-清除算法
2. 复制算法
3. 标记压缩算法

#### 标记清除算法
当堆中有效内存被耗尽的时候，停止整个程序（**Stop the world**）
标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般在对象的Header中记录为可达对象
清除：Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。

缺点：
>效率不算高  
>在进行GC的时候，需要停止整个程序  
>这种方式清理出来的内存空间不是连续的，产生内存碎片，需要维护一个空闲列表

#### 复制算法
将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中存活对象
复制到未使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色。

优点：
> 没有标记清除过程，实现简单，运行高效  
>复制过去保证空间的连续性，不会出现“碎片”问题

缺点：
> 此算法需要两倍的内存空间  
>对于G1这种拆分为大量的Redgion的GC，复制而不是移动，意味着GC需要维护region之间的
>引用关系，不管是内存占用或者时间开销也不小

应用场景:
> 在新生代，对常规应用的垃圾回收，一次通常可以回收70-99号的内存空间
>回收性价比很高。所以现在的商业虚拟机都是这种算法回收新生代

#### 标记压缩算法
第一阶段：跟标记清除算法一样
第二阶段：将所有存活对象压缩到内存的一端，按顺序排放
之后清理边界外所有空间


### 收集算法
#### 分代收集算法
##### 年轻代

##### 老年代


#### 增量收集算法（CMS）
1. 初始标记
2. 并发标记

#### 分区算法（G1）
每一个小区间独立使用，独立回收。这种算法好处是可控制一次回收多少个小区间

方法逃逸
> 方法里创建对象对象，从创建到使用都没有溢出到方法之外。这就表示未逃逸。会在栈上内存分配  
> 通过返回值，在方法外可以调用它。发送方法逃逸会在推上分配内存


#### GC分类
按GC线程数分：
> 串行垃圾回收器和并行垃圾回收器